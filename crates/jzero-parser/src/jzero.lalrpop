use crate::action::TreeAction;
use crate::lexer::{Tok, LexicalError};
use crate::loc::line_from_offset;
use jzero_ast::tree::Tree;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Tok<'input> {
        "break" => Tok::Break,
        "double" => Tok::Double,
        "else" => Tok::Else,
        "for" => Tok::For,
        "if" => Tok::If,
        "int" => Tok::Int,
        "return" => Tok::Return,
        "void" => Tok::Void,
        "while" => Tok::While,
        "identifier" => Tok::Identifier(<&'input str>),
        "class" => Tok::Class,
        "string" => Tok::StringKw,
        "bool" => Tok::Bool,
        "intlit" => Tok::IntLit(<&'input str>),
        "doublelit" => Tok::DoubleLit(<&'input str>),
        "stringlit" => Tok::StringLit(<&'input str>),
        "boollit" => Tok::BoolLit(<bool>),
        "null" => Tok::Null,
        "<=" => Tok::LessEqual,
        ">=" => Tok::GreaterEqual,
        "==" => Tok::EqualEqual,
        "!=" => Tok::NotEqual,
        "&&" => Tok::LogicalAnd,
        "||" => Tok::LogicalOr,
        "+=" => Tok::PlusAssign,
        "-=" => Tok::MinusAssign,
        "public" => Tok::Public,
        "static" => Tok::Static,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        "[" => Tok::LBracket,
        "]" => Tok::RBracket,
        ";" => Tok::Semicolon,
        "," => Tok::Comma,
        "." => Tok::Dot,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Star,
        "/" => Tok::Slash,
        "%" => Tok::Percent,
        "=" => Tok::Assign,
        "!" => Tok::Bang,
        "<" => Tok::Less,
        ">" => Tok::Greater,
    }
}

// ─── Top-level ───────────────────────────────────────────

pub ClassDecl: Tree = {
    "public" "class" <l:@L> <name:"identifier"> <body:ClassBody> => {
        let n = Tree::leaf("IDENTIFIER", name, line_from_offset(input, l));
        let mut kids = vec![n];
        kids.extend(body);
        Tree::new("ClassDecl", 0, kids)
    },
};

ClassBody: Vec<Tree> = {
    "{" <decls:ClassBodyDecls> "}" => decls,
    "{" "}" => vec![],
};

ClassBodyDecls: Vec<Tree> = {
    <d:ClassBodyDecl> => vec![d],
    <mut ds:ClassBodyDecls> <d:ClassBodyDecl> => { ds.push(d); ds },
};

ClassBodyDecl: Tree = {
    FieldDecl => <>,
    MethodDecl => <>,
    ConstructorDecl => <>,
};

FieldDecl: Tree = {
    <ty:Type> <decls:VarDecls> ";" =>
        Tree::new("FieldDecl", 0, { let mut v = vec![ty]; v.extend(decls); v }),
};

Type: Tree = {
    <l:@L> "int" => Tree::leaf("INT", "int", line_from_offset(input, l)),
    <l:@L> "double" => Tree::leaf("DOUBLE", "double", line_from_offset(input, l)),
    <l:@L> "bool" => Tree::leaf("BOOL", "bool", line_from_offset(input, l)),
    <l:@L> "string" => Tree::leaf("STRING", "string", line_from_offset(input, l)),
    <l:@L> <name:"identifier"> => Tree::leaf("IDENTIFIER", name, line_from_offset(input, l)),
};

VarDecls: Vec<Tree> = {
    <d:VarDeclarator> => vec![d],
    <mut ds:VarDecls> "," <d:VarDeclarator> => { ds.push(d); ds },
};

VarDeclarator: Tree = {
    <l:@L> <name:"identifier"> =>
        Tree::new("VarDeclarator", 0, vec![Tree::leaf("IDENTIFIER", name, line_from_offset(input, l))]),
    <vd:VarDeclarator> "[" "]" =>
        Tree::new("VarDeclarator", 1, vec![vd]),
};

// ─── Methods and constructors ────────────────────────────

MethodReturnVal: Tree = {
    Type => <>,
    <l:@L> "void" => Tree::leaf("VOID", "void", line_from_offset(input, l)),
};

MethodDecl: Tree = {
    <hdr:MethodHeader> <body:Block> =>
        Tree::new("MethodDecl", 0, vec![hdr, body]),
};

MethodHeader: Tree = {
    "public" "static" <ret:MethodReturnVal> <decl:MethodDeclarator> =>
        Tree::new("MethodHeader", 0, vec![ret, decl]),
};

MethodDeclarator: Tree = {
    <l:@L> <name:"identifier"> "(" <params:FormalParmListOpt> ")" => {
        let n = Tree::leaf("IDENTIFIER", name, line_from_offset(input, l));
        let mut kids = vec![n];
        kids.extend(params);
        Tree::new("MethodDeclarator", 0, kids)
    },
};

FormalParmListOpt: Vec<Tree> = {
    <list:FormalParmList> => list,
    => vec![],
};

FormalParmList: Vec<Tree> = {
    <p:FormalParm> => vec![p],
    <mut ps:FormalParmList> "," <p:FormalParm> => { ps.push(p); ps },
};

FormalParm: Tree = {
    <ty:Type> <vd:VarDeclarator> =>
        Tree::new("FormalParm", 0, vec![ty, vd]),
};

ConstructorDecl: Tree = {
    <decl:ConstructorDeclarator> <body:Block> =>
        Tree::new("ConstructorDecl", 0, vec![decl, body]),
};

ConstructorDeclarator: Tree = {
    <l:@L> <name:"identifier"> "(" <params:FormalParmListOpt> ")" => {
        let n = Tree::leaf("IDENTIFIER", name, line_from_offset(input, l));
        let mut kids = vec![n];
        kids.extend(params);
        Tree::new("ConstructorDeclarator", 0, kids)
    },
};

// ─── Blocks and statements ──────────────────────────────

Block: Tree = {
    "{" <stmts:BlockStmtsOpt> "}" =>
        Tree::new("Block", 0, stmts),
};

BlockStmtsOpt: Vec<Tree> = {
    <stmts:BlockStmts> => stmts,
    => vec![],
};

BlockStmts: Vec<Tree> = {
    <s:BlockStmt> => vec![s],
    <mut ss:BlockStmts> <s:BlockStmt> => { ss.push(s); ss },
};

// BlockStmt is left-factored to resolve the IDENTIFIER ambiguity.
BlockStmt: Tree = {
    <ty:PrimitiveType> <decls:VarDecls> ";" =>
        Tree::new("LocalVarDecl", 0, { let mut v = vec![ty]; v.extend(decls); v }),
    <l:@L> <name:"identifier"> <rest:IdentifierStartedStmt> => {
        let id = Tree::leaf("IDENTIFIER", name, line_from_offset(input, l));
        rest.apply(id)
    },
    Stmt => <>,
};

// IdentifierStartedStmt returns a closure that takes the leading IDENTIFIER
// leaf and produces the final statement Tree node.
IdentifierStartedStmt: TreeAction<'input> = {
    // Variable declaration: Type varname ...;
    <l:@L> <varname:"identifier"> <rest:VarDeclRest> => {
        let line = line_from_offset(input, l);
        TreeAction::new(move |type_id: Tree| {
            let vd_name = Tree::leaf("IDENTIFIER", varname, line);
            let first_vd = Tree::new("VarDeclarator", 0, vec![vd_name]);
            let mut kids = vec![type_id, first_vd];
            kids.extend(rest);
            Tree::new("LocalVarDecl", 0, kids)
        })
    },
    // Array type: IDENTIFIER[] VarDecls ;
    "[" "]" <decls:VarDecls> ";" => {
        TreeAction::new(move |type_id: Tree| {
            let arr_type = Tree::new("ArrayType", 0, vec![type_id]);
            let mut kids = vec![arr_type];
            kids.extend(decls);
            Tree::new("LocalVarDecl", 1, kids)
        })
    },
    // Simple call: IDENTIFIER(args);
    "(" <args:ArgListOpt> ")" ";" => {
        TreeAction::new(move |name_id: Tree| {
            let mut kids = vec![name_id];
            kids.extend(args);
            Tree::new("MethodCall", 0, kids)
        })
    },
    // Brace call: IDENTIFIER{args};
    "{" <args:ArgListOpt> "}" ";" => {
        TreeAction::new(move |name_id: Tree| {
            let mut kids = vec![name_id];
            kids.extend(args);
            Tree::new("MethodCall", 1, kids)
        })
    },
    // Dotted: IDENTIFIER.identifier DotTail
    "." <l:@L> <field:"identifier"> <tail:DotTail> => {
        let line = line_from_offset(input, l);
        TreeAction::new(move |base_id: Tree| {
            let field_leaf = Tree::leaf("IDENTIFIER", field, line);
            let access = Tree::new("FieldAccess", 0, vec![base_id, field_leaf]);
            tail.apply(access)
        })
    },
    // Assignment: IDENTIFIER AssignOp Expr ;
    <op:AssignOp> <rhs:Expr> ";" => {
        TreeAction::new(move |name_id: Tree| {
            Tree::new("Assignment", 0, vec![name_id, op, rhs])
        })
    },
};

VarDeclRest: Vec<Tree> = {
    ";" => vec![],
    "," <decls:VarDecls> ";" => decls,
    "[" "]" <rest:ArrayVarDeclRest> => {
        // First var declarator gets array brackets
        rest
    },
};

ArrayVarDeclRest: Vec<Tree> = {
    ";" => vec![],
    "," <decls:VarDecls> ";" => decls,
    "[" "]" <rest:ArrayVarDeclRest> => rest,
};

// DotTail returns a closure: takes the AccessExpr built so far, returns final stmt Tree.
DotTail: TreeAction<'input> = {
    // Chain continues: .identifier DotTail
    "." <l:@L> <field:"identifier"> <tail:DotTail> => {
        let line = line_from_offset(input, l);
        TreeAction::new(move |base: Tree| {
            let field_leaf = Tree::leaf("IDENTIFIER", field, line);
            let access = Tree::new("FieldAccess", 0, vec![base, field_leaf]);
            tail.apply(access)
        })
    },
    // Method call: (args) CallTail
    "(" <args:ArgListOpt> ")" <tail:CallTail> => {
        TreeAction::new(move |base: Tree| {
            let mut kids = vec![base];
            kids.extend(args);
            let call = Tree::new("MethodCall", 0, kids);
            tail.apply(call)
        })
    },
    // Brace call: {args} CallTail
    "{" <args:ArgListOpt> "}" <tail:CallTail> => {
        TreeAction::new(move |base: Tree| {
            let mut kids = vec![base];
            kids.extend(args);
            let call = Tree::new("MethodCall", 1, kids);
            tail.apply(call)
        })
    },
    // Assignment to field: AssignOp Expr ;
    <op:AssignOp> <rhs:Expr> ";" => {
        TreeAction::new(move |base: Tree| {
            Tree::new("Assignment", 0, vec![base, op, rhs])
        })
    },
};

// CallTail: after a method call in statement position.
CallTail: TreeAction<'input> = {
    // Statement ends
    ";" => TreeAction::new(|call: Tree| call),
    // Chain continues: .identifier DotTail
    "." <l:@L> <field:"identifier"> <tail:DotTail> => {
        let line = line_from_offset(input, l);
        TreeAction::new(move |call: Tree| {
            let field_leaf = Tree::leaf("IDENTIFIER", field, line);
            let access = Tree::new("FieldAccess", 0, vec![call, field_leaf]);
            tail.apply(access)
        })
    },
};

PrimitiveType: Tree = {
    <l:@L> "int" => Tree::leaf("INT", "int", line_from_offset(input, l)),
    <l:@L> "double" => Tree::leaf("DOUBLE", "double", line_from_offset(input, l)),
    <l:@L> "bool" => Tree::leaf("BOOL", "bool", line_from_offset(input, l)),
    <l:@L> "string" => Tree::leaf("STRING", "string", line_from_offset(input, l)),
};

Stmt: Tree = {
    Block => <>,
    <l:@L> ";" => Tree::new("EmptyStmt", 0, vec![]),
    BreakStmt => <>,
    ReturnStmt => <>,
    IfThenElseStmt => <>,
    IfThenStmt => <>,
    WhileStmt => <>,
    ForStmt => <>,
};

// ─── If / else ──────────────────────────────────────────

IfThenStmt: Tree = {
    "if" "(" <cond:Expr> ")" <body:Block> =>
        Tree::new("IfThenStmt", 0, vec![cond, body]),
};

IfThenElseStmt: Tree = {
    "if" "(" <cond:Expr> ")" <then_body:Block> "else" <else_body:ElseBody> =>
        Tree::new("IfThenElseStmt", 0, vec![cond, then_body, else_body]),
};

ElseBody: Tree = {
    Block => <>,
    IfThenElseStmt => <>,
    IfThenStmt => <>,
};

// ─── Loops ──────────────────────────────────────────────

WhileStmt: Tree = {
    "while" "(" <cond:Expr> ")" <body:Stmt> =>
        Tree::new("WhileStmt", 0, vec![cond, body]),
};

ForStmt: Tree = {
    "for" "(" <init:ForInit> ";" <cond:ExprOpt> ";" <upd:ForUpdate> ")" <body:Block> => {
        let mut kids = Vec::new();
        if let Some(i) = init { kids.push(i); } else { kids.push(Tree::new("EmptyForInit", 0, vec![])); }
        if let Some(c) = cond { kids.push(c); } else { kids.push(Tree::new("EmptyExpr", 0, vec![])); }
        if let Some(u) = upd { kids.push(u); } else { kids.push(Tree::new("EmptyForUpdate", 0, vec![])); }
        kids.push(body);
        Tree::new("ForStmt", 0, kids)
    },
};

ForInit: Option<Tree> = {
    <ty:PrimitiveType> <decls:VarDecls> => {
        let mut kids = vec![ty];
        kids.extend(decls);
        Some(Tree::new("LocalVarDecl", 0, kids))
    },
    <l:@L> <name:"identifier"> <rest:ForInitAfterIdent> => {
        let id = Tree::leaf("IDENTIFIER", name, line_from_offset(input, l));
        Some(rest.apply(id))
    },
    => None,
};

ForInitAfterIdent: TreeAction<'input> = {
    // Type name: IDENTIFIER VarDecls
    <l:@L> <varname:"identifier"> <rest:ForInitVarDeclRest> => {
        let line = line_from_offset(input, l);
        TreeAction::new(move |type_id: Tree| {
            let vd_name = Tree::leaf("IDENTIFIER", varname, line);
            let first_vd = Tree::new("VarDeclarator", 0, vec![vd_name]);
            let mut kids = vec![type_id, first_vd];
            kids.extend(rest);
            Tree::new("LocalVarDecl", 0, kids)
        })
    },
    "[" "]" <decls:VarDecls> => {
        TreeAction::new(move |type_id: Tree| {
            let arr_type = Tree::new("ArrayType", 0, vec![type_id]);
            let mut kids = vec![arr_type];
            kids.extend(decls);
            Tree::new("LocalVarDecl", 1, kids)
        })
    },
    // Method call: IDENTIFIER(args)
    "(" <args:ArgListOpt> ")" => {
        TreeAction::new(move |name_id: Tree| {
            let mut kids = vec![name_id];
            kids.extend(args);
            Tree::new("MethodCall", 0, kids)
        })
    },
    "{" <args:ArgListOpt> "}" => {
        TreeAction::new(move |name_id: Tree| {
            let mut kids = vec![name_id];
            kids.extend(args);
            Tree::new("MethodCall", 1, kids)
        })
    },
    // Dotted call/assign in for-init
    "." <l:@L> <field:"identifier"> <tail:ForInitDotTail> => {
        let line = line_from_offset(input, l);
        TreeAction::new(move |base_id: Tree| {
            let field_leaf = Tree::leaf("IDENTIFIER", field, line);
            let access = Tree::new("FieldAccess", 0, vec![base_id, field_leaf]);
            tail.apply(access)
        })
    },
    // Assignment: IDENTIFIER AssignOp Expr
    <op:AssignOp> <rhs:Expr> => {
        TreeAction::new(move |name_id: Tree| {
            Tree::new("Assignment", 0, vec![name_id, op, rhs])
        })
    },
};

ForInitVarDeclRest: Vec<Tree> = {
    => vec![],
    "," <decls:VarDecls> => decls,
    "[" "]" <rest:ForInitArrayVarDeclRest> => rest,
};

ForInitArrayVarDeclRest: Vec<Tree> = {
    => vec![],
    "," <decls:VarDecls> => decls,
    "[" "]" <rest:ForInitArrayVarDeclRest> => rest,
};

ForInitDotTail: TreeAction<'input> = {
    "." <l:@L> <field:"identifier"> <tail:ForInitDotTail> => {
        let line = line_from_offset(input, l);
        TreeAction::new(move |base: Tree| {
            let field_leaf = Tree::leaf("IDENTIFIER", field, line);
            let access = Tree::new("FieldAccess", 0, vec![base, field_leaf]);
            tail.apply(access)
        })
    },
    "(" <args:ArgListOpt> ")" => {
        TreeAction::new(move |base: Tree| {
            let mut kids = vec![base];
            kids.extend(args);
            Tree::new("MethodCall", 0, kids)
        })
    },
    "{" <args:ArgListOpt> "}" => {
        TreeAction::new(move |base: Tree| {
            let mut kids = vec![base];
            kids.extend(args);
            Tree::new("MethodCall", 1, kids)
        })
    },
    <op:AssignOp> <rhs:Expr> => {
        TreeAction::new(move |base: Tree| {
            Tree::new("Assignment", 0, vec![base, op, rhs])
        })
    },
};

ExprOpt: Option<Tree> = {
    <e:Expr> => Some(e),
    => None,
};

ForUpdate: Option<Tree> = {
    <list:StmtExprList> => Some(list),
    => None,
};

StmtExprList: Tree = {
    <e:StmtExpr> => e,
    <list:StmtExprList> "," <e:StmtExpr> =>
        Tree::new("StmtExprList", 0, vec![list, e]),
};

StmtExpr: Tree = {
    AccessExpr => <>,
    <lhs:AccessExpr> <op:AssignOp> <rhs:Expr> =>
        Tree::new("Assignment", 0, vec![lhs, op, rhs]),
};

// ─── Break / return ─────────────────────────────────────

BreakStmt: Tree = {
    "break" ";" => Tree::new("BreakStmt", 0, vec![]),
    "break" <l:@L> <label:"identifier"> ";" =>
        Tree::new("BreakStmt", 1, vec![Tree::leaf("IDENTIFIER", label, line_from_offset(input, l))]),
};

ReturnStmt: Tree = {
    "return" <e:ExprOpt> ";" => {
        match e {
            Some(expr) => Tree::new("ReturnStmt", 0, vec![expr]),
            None => Tree::new("ReturnStmt", 1, vec![]),
        }
    },
};

// ─── Expressions ─────────────────────────────────────────

AtomExpr: Tree = {
    Literal => <>,
    <l:@L> <name:"identifier"> => Tree::leaf("IDENTIFIER", name, line_from_offset(input, l)),
    "(" <e:Expr> ")" => e,
};

Literal: Tree = {
    <l:@L> <v:"intlit"> => Tree::leaf("INTLIT", v, line_from_offset(input, l)),
    <l:@L> <v:"doublelit"> => Tree::leaf("DOUBLELIT", v, line_from_offset(input, l)),
    <l:@L> <v:"boollit"> => Tree::leaf("BOOLLIT", if v { "true" } else { "false" }, line_from_offset(input, l)),
    <l:@L> <v:"stringlit"> => Tree::leaf("STRINGLIT", v, line_from_offset(input, l)),
    <l:@L> "null" => Tree::leaf("NULL", "null", line_from_offset(input, l)),
};

AccessExpr: Tree = {
    AtomExpr => <>,
    <l:@L> <name:"identifier"> "(" <args:ArgListOpt> ")" => {
        let n = Tree::leaf("IDENTIFIER", name, line_from_offset(input, l));
        let mut kids = vec![n];
        kids.extend(args);
        Tree::new("MethodCall", 0, kids)
    },
    <l:@L> <name:"identifier"> "{" <args:ArgListOpt> "}" => {
        let n = Tree::leaf("IDENTIFIER", name, line_from_offset(input, l));
        let mut kids = vec![n];
        kids.extend(args);
        Tree::new("MethodCall", 1, kids)
    },
    <base:AccessExpr> "." <l:@L> <field:"identifier"> =>
        Tree::new("FieldAccess", 0, vec![base, Tree::leaf("IDENTIFIER", field, line_from_offset(input, l))]),
    <base:AccessExpr> "." <l:@L> <method:"identifier"> "(" <args:ArgListOpt> ")" => {
        let m = Tree::leaf("IDENTIFIER", method, line_from_offset(input, l));
        let mut kids = vec![base, m];
        kids.extend(args);
        Tree::new("MethodCall", 2, kids)
    },
    <base:AccessExpr> "." <l:@L> <method:"identifier"> "{" <args:ArgListOpt> "}" => {
        let m = Tree::leaf("IDENTIFIER", method, line_from_offset(input, l));
        let mut kids = vec![base, m];
        kids.extend(args);
        Tree::new("MethodCall", 3, kids)
    },
};

ArgListOpt: Vec<Tree> = {
    <list:ArgList> => list,
    => vec![],
};

ArgList: Vec<Tree> = {
    <e:Expr> => vec![e],
    <mut es:ArgList> "," <e:Expr> => { es.push(e); es },
};

UnaryExpr: Tree = {
    <l:@L> "-" <e:UnaryExpr> =>
        Tree::new("UnaryMinus", 0, vec![e]),
    <l:@L> "!" <e:UnaryExpr> =>
        Tree::new("UnaryNot", 0, vec![e]),
    AccessExpr => <>,
};

MulExpr: Tree = {
    UnaryExpr => <>,
    <lhs:MulExpr> <l:@L> "*" <rhs:UnaryExpr> =>
        Tree::new("MulExpr", 0, vec![lhs, Tree::leaf("STAR", "*", line_from_offset(input, l)), rhs]),
    <lhs:MulExpr> <l:@L> "/" <rhs:UnaryExpr> =>
        Tree::new("MulExpr", 1, vec![lhs, Tree::leaf("SLASH", "/", line_from_offset(input, l)), rhs]),
    <lhs:MulExpr> <l:@L> "%" <rhs:UnaryExpr> =>
        Tree::new("MulExpr", 2, vec![lhs, Tree::leaf("PERCENT", "%", line_from_offset(input, l)), rhs]),
};

AddExpr: Tree = {
    MulExpr => <>,
    <lhs:AddExpr> <l:@L> "+" <rhs:MulExpr> =>
        Tree::new("AddExpr", 0, vec![lhs, Tree::leaf("PLUS", "+", line_from_offset(input, l)), rhs]),
    <lhs:AddExpr> <l:@L> "-" <rhs:MulExpr> =>
        Tree::new("AddExpr", 1, vec![lhs, Tree::leaf("MINUS", "-", line_from_offset(input, l)), rhs]),
};

RelOp: Tree = {
    <l:@L> "<=" => Tree::leaf("LESSEQUAL", "<=", line_from_offset(input, l)),
    <l:@L> ">=" => Tree::leaf("GREATEREQUAL", ">=", line_from_offset(input, l)),
    <l:@L> "<" => Tree::leaf("LESS", "<", line_from_offset(input, l)),
    <l:@L> ">" => Tree::leaf("GREATER", ">", line_from_offset(input, l)),
};

RelExpr: Tree = {
    AddExpr => <>,
    <lhs:RelExpr> <op:RelOp> <rhs:AddExpr> =>
        Tree::new("RelExpr", 0, vec![lhs, op, rhs]),
};

EqExpr: Tree = {
    RelExpr => <>,
    <lhs:EqExpr> <l:@L> "==" <rhs:RelExpr> =>
        Tree::new("EqExpr", 0, vec![lhs, Tree::leaf("EQUALEQUAL", "==", line_from_offset(input, l)), rhs]),
    <lhs:EqExpr> <l:@L> "!=" <rhs:RelExpr> =>
        Tree::new("EqExpr", 1, vec![lhs, Tree::leaf("NOTEQUAL", "!=", line_from_offset(input, l)), rhs]),
};

CondAndExpr: Tree = {
    EqExpr => <>,
    <lhs:CondAndExpr> <l:@L> "&&" <rhs:EqExpr> =>
        Tree::new("CondAndExpr", 0, vec![lhs, Tree::leaf("LOGICALAND", "&&", line_from_offset(input, l)), rhs]),
};

CondOrExpr: Tree = {
    CondAndExpr => <>,
    <lhs:CondOrExpr> <l:@L> "||" <rhs:CondAndExpr> =>
        Tree::new("CondOrExpr", 0, vec![lhs, Tree::leaf("LOGICALOR", "||", line_from_offset(input, l)), rhs]),
};

Expr: Tree = {
    CondOrExpr => <>,
    <lhs:AccessExpr> <op:AssignOp> <rhs:Expr> =>
        Tree::new("Assignment", 0, vec![lhs, op, rhs]),
};

Assignment: Tree = <lhs:LeftHandSide> <op:AssignOp> <rhs:Expr> =>
    Tree::new("Assignment", 0, vec![lhs, op, rhs]);

LeftHandSide: Tree = {
    <l:@L> <name:"identifier"> => Tree::leaf("IDENTIFIER", name, line_from_offset(input, l)),
};

AssignOp: Tree = {
    <l:@L> "=" => Tree::leaf("ASSIGN", "=", line_from_offset(input, l)),
    <l:@L> "+=" => Tree::leaf("PLUSASSIGN", "+=", line_from_offset(input, l)),
    <l:@L> "-=" => Tree::leaf("MINUSASSIGN", "-=", line_from_offset(input, l)),
};